import {useState} from 'react'

import './App.css'
import {QuestionsSection} from "./components/QuestionsSection.jsx";

const questionHtml = [
    {
        title: "1. Расскажите как работает браузер? ",
        description:
            <>
                Браузер - это программное обеспечение, которое позволяет пользователям просматривать и взаимодействовать
                с веб-страницами. Вот основные шаги, которые браузер выполняет для отображения веб-страницы:
                <br/>
                <br/>
                1. <u><strong>Ввод URL:</strong></u> Пользователь вводит URL (Uniform Resource Locator) в адресную
                строку браузера. URL указывает на веб-страницы, которую пользователь хочет посетить.
                <br/>
                <br/>
                2. <u><strong>Хост файлы на компьютере.</strong></u> Если ранее уже были запросы. Вернет Айпи уже,
                который знает.
                <br/>
                <br/>
                3. <u><strong>DNS-запрос:</strong></u> Браузер отправляет DNS-запрос (Domain Name System) на DNS-сервер,
                чтобы получить IP-сервера, на котором храниться веб-страница. DNS-сервер преобразует доменное имя
                (например, www.example.com) в соответствующий IP-адрес.
                <br/>
                <br/>
                4. <u><strong> Установка соединения:</strong></u> Браузер устанавливает ТСР-соединение с сервером,
                используя полученный IP-адрес. Это позволяет браузеру отправлять и получать данные с сервера.
                <br/>
                <br/>
                5. <u><strong> Запрос страницы:</strong></u> Браузер отправляет HTTP-запрос (Hypertext Transfer
                Protocol) на сервер, запрашивая веб-страницу. Запрос может содержать различные параметры, такие как
                методы запроса (GET, POST и т. д.) заголовки и тело запроса.
                <br/>
                <br/>
                6. <u><strong> Получение ответа: </strong></u> Сервер обрабатывает запрос и отправляет обратно
                HTTP-ответ, содержащий запрошенную веб-страницу. Ответ может так же содержать различные заголовки,
                статус ответа и тело ответа. Браузер анализирует заголовки ответа. Заголовки могут содержать важную
                информацию, такую как тип контента (Content-Type), правила кеширования и т.д.
                <br/>
                <br/>
                7. <u><strong>Рендеринг страницы:</strong></u> Браузер получает ответ от сервера и начинает обрабатывать
                его. Он анализирует HTML-код страницы, строит DOM (Document Object Model) - внутреннее представление
                страницы, и создает дерево элементов.
                <br/>
                <br/>
                8. <u><strong> Загрузка ресурсов:</strong></u> Браузер загружает все связанные ресурсы, такие как
                изображения, стили CSS, скрипты JavaScript и другие файлы, указанные в HTML-коде страницы.
                <br/>
                <br/>
                9. <u><strong>Отображение страницы:</strong></u> Браузер использует полученные ресурсы и информацию о
                стилях для отображения страницы на экране. Он располагает элементы в соответствии с их CSS-свойствами,
                применяет шрифты, цвета и другие стили, и отображает содержимое страницы.
            </>,

    },
    {
        title: "2. Какие есть этапы рендеринга html страницы?",
        description:
            <>
                1. Парсинг HTML
                <br/>
                + Браузер начинает парсить HTML-документ и строить DOM-дерево (Document Object Model), представляющее
                иерархическую структуру всех элементов страницы.
                <br/>
                + Если браузер находит <code>&lt;script&gt;</code>, он приостанавливает парсинг, загружает и выполняет
                скрипт, что может изменить структуру DOM.
                <br/>
                <br/>
                2. Загрузка внешних ресурсов
                <br/>
                +Во время парсинга HTML браузер обнаруживает ссылки на внешние ресурсы (СSS, изображения, шрифты,
                скрипты) и начинает их загружать параллельно.
                <br/>
                + CSS загружается и парсится, формируя CSSOM (CSS Object Model).
                <br/>
                <br/>
                3. Построение рендер-дерева
                <br/>
                + DOM и CSSOM обьединяются для создания рендер-дерева, которое представляет собой структуру элементов,
                подлежащих отображению на экране с примененными стилями.
                <br/>
                <br/>
                4. Вычисление гиометрии (Layout)
                <br/>
                + Браузер вычисляет размеры и приложения каждого элемента на странице, основываясь на рендер-дереве.
                Этот процесс называется layout или reflow.
                <br/>
                <br/>
                5 Отрисовка (Painting)
                <br/>
                Браузер преобразует рендер-дерево в пиксели на экране, рисуя текст, цвета, изображения, тени и другие
                графические элементы.
                <br/>
                <br/>
                6. Композиция (Compositing)
                <br/>
                Некоторые элементы могут быть отрисованы в отдельных слоях для улучшения производительности(например
                анимация или фиксированные элементы). На этапе композиции браузер объединяет эти слои в одно изображение
                для отображения на экране.
                <br/>
                <br/>
                7. Интерфейс пользователя (UI)
                <br/>
                +Браузер обрабатывает пользовательские события(клики, прокрутки, ввод данных и т д)
                <br/>
                + JavaScript может изменять DOM, что может запустить повторные этапы layout и painting.
            </>,
    },
]

const questionCss = [
    {
        title: "1. В чем разница между box-sizing: content-box и box-sizing: border-box?",
        description:
            <>
                <u><strong> box-sizing: content-box </strong></u> Размер элемента считается только по содержимому
                (content).
                Ширина и высота не включают в себя padding (внутренние отступы) и border (границы).
                Их нужно прибавлять отдельно, поэтому итоговый размер элемента будет больше, чем указано..
                <br/>
                <br/>
                <u><strong> box-sizing: border-box </strong></u> Размер элемента включает в себя и content, и padding, и
                border.
                То есть, общая ширина и высота элемента остаются фиксированными, и отступы/границы просто уменьшают
                область для содержимого.
                Удобно при адаптивной вёрстке, потому что проще управлять размерами блоков.


            </>
    }
]

const questionJs = [
    {
        title: "1. Как узнать какого типа переменная? Что и в каком виде возвращает typeof",
        description: (
            <>
                Оператор <u><strong>typeof</strong></u> возвращает тип аргумента. Это полезно, когда мы хотим обработать
                значения разных типов по-разному или просто хотим сделать проверку.
                <br/>
                У него есть 2 синтаксические формы:
                <br/>
                <br/>
                //Обычный синтаксис
                <br/>
                typeof 5 // Выведет 'number'
                <br/>
                <br/>
                //Синтаксис, напоминающий вызов функции. Встречается реже.
                <br/>
                typeof (5) // Выведет 'number'
                <br/>
                <br/>
                Если передается выражение, то нужно заключать его в скобки, тк <u><strong>typeof</strong></u> имеет
                более высокий приоритет, чем бинарные операторы. Другими словами, скобки необходимы для определения типа
                значения, которое получилось в результате выполнения выражения в них.
                <br/>
                <br/>
                typeof 50 + ' Квартир'; // Выведет 'number Квартир'
                <br/>
                typeof (50 + ' Квартир'); // Выведет 'string'
            </>

        ),
    },
    {
        title: "2. Зачем для тега <script> добавляют атрибуты async и defer?",
        description: (
            <>
                Без использования атрибутов в теге <strong>&lt;script&gt;</strong>, когда браузер загружает HTML и
                доходит до тега <strong>&lt;script&gt;</strong>,
                то он может дальше строить DOM, пока не выполнит скрипт. Соответственно потребуется больше времени для
                того, чтобы показать пользователю готовую страницу. <br/>
                Для решения этой проблемы тег <strong>&lt;script&gt;</strong> можно поместить в конец страницы. Но это
                не идеальное решение, так как выполнение скрипта может начаться с сильной задержкой. Для этого есть
                атрибуты:
                <br/><br/>
                <u><strong>async:</strong></u> Свойство async для тега <strong>&lt;script&gt;</strong> указывает
                браузеру загружать скрипт асинхронно, не блокируя последующий парсинг HTML или выполнение других
                скриптов на странице. <br/>
                Скрипт с атрибутом async загружается параллельно с парсингом HTML и выполняется сразу после завершения
                загрузки. Порядок выполнения скриптов не гарантируется. <br/>
                Подходит для скриптов, которые не зависят от других ресурсов на странице и могут быть выполнены
                независимо от них. <br/><br/>
                <u><strong>defer:</strong></u> Свойство defer для тега <strong>&lt;script&gt;</strong> говорит браузеру
                загружать скрипт асинхронно, но откладывать его выполнение до завершения парсинга HTML. <br/>
                Скрипты с атрибутом defer загружаются параллельно с парсингом HTML, но их выполнение откладывается до
                завершения парсинга. Они выполняются в том порядке, в котором указаны в HTML, перед событием
                DOMContentLoaded. <br/>
                Использование async и defer помогает ускорить загрузку страницы, улучшить воспроизводимость скриптов и
                повысить производительность веб-страницы.
            </>
        ),
    },
    {
        title: "3. Что такое замыкания в JS и почему они важны?",
        description: "Замыкания в JS - это функция, которая запоминает свое окружение во время создания и может использовать переменные из этого окружения даже после того, как это окружение прекратило свое существование. Они важны, потому что позволяют создавать приватные переменные, сохранять состояние и делать код более модульным.",
    },
    {
        title: "4. Что такое NaN? Какого типа это значения? Как можно узнать, равно ли значение переменной NaN?",
        description:
            <>
                NaN означает 'Not-A-Number' и является специальным значением в JS, которое указывает на ошибку при
                выполнении математических операций, когда результат не является числом. Тип значения NaN в JS - это
                число (Number).
                <br/>
                Чтобы проверить,равно ли значение переменной NaN, можно использовать функцию isNaN(). Например:
                <br/>
                <br/>
                let result = 10 / 'привет'; <br/>
                console.log(isNaN(result)); // Вернет true, т к результат деления не является числом
            </>
    },
    {
        title: "5. Какие бинарные операторы вы знаете?",
        description:

            <>
                Бинарные операторы работают с двумя операндами.
                <br/><br/>
                <strong>1. Арифметические (Используются для выполнения математических операций.): </strong>
                <br/>
                <code>(+)</code> — сложение: <code>a + b</code><br/>
                <code>(-)</code> — вычитание: <code>a - b</code><br/>
                <code>(*)</code> — умножение: <code>a * b</code><br/>
                <code>(/)</code> — деление: <code>a / b</code><br/>
                <code>(%)</code> — остаток от деления: <code>a % b</code><br/>
                <code>(**)</code> — возведение в степень: <code>a ** b</code>
                <br/><br/>
                <strong>2. Операторы сравнения (Используются для сравнения двух значений.):</strong>
                <br/>
                <code>(==)</code> — нестрогое равенство<br/>
                <code>(!=)</code> — нестрогое неравенство<br/>
                <code>(===)</code> — строгое равенство<br/>
                <code>(!==)</code> — строгое неравенство<br/>
                <code>(&gt;)</code> — больше<br/>
                <code>(&lt;)</code> — меньше<br/>
                <code>(&gt;=)</code> — больше или равно<br/>
                <code>(&lt;=)</code> — меньше или равно
                <br/><br/>
                <strong>3. Логические (Используются для выполнения логических операций.):</strong>
                <br/>
                <code>(&&)</code> — логическое И<br/>
                <code>(||)</code> — логическое ИЛИ
            </>
    },
    {
        title: "6. Отличие null и undefined?",
        description:
            <>
                null явно указывает на отсутствие значения или пустое состояние. Это как бы “нуль” для объектов.
                <br/>
                null обычно используется для обозначения пустой или несуществующей ссылки на объект.
                <br/>
                undefined означает, что переменная была объявлена, но ей еще не присвоено значение.
                Это значение по умолчанию для необъявленных или неинициализированных переменных.
                <br/>
                Undefined не равен ничему кроме себя, но null == undefined;
                <br/>
                <br/>
                typeof null === “object” а typeof undefined === ‘undefined’
            </>,
    },
    {
        title: "7. Отличия межу arrow function (Стрелочные функции)  function declaration  function expression?",
        description:
            <>
                <u><strong>Function Declaration</strong></u> создается до выполнения кода, так что ее можно вызвать до
                того, как она была написана. this зависит от контекста, в котором функция вызвана.
                <br/>
                <u><strong>Function Expression</strong></u> - Функции, присвоенные переменной, как правило, не имеют
                имени и их нельзя вызвать до того, как они были определены.
                <br/>
                Declaration – function sum(a,b){};
                <br/>
                Expression – const sum = function (a,b){}
                <br/>

                <u><strong> Arrow Functions (Стрелочные функции)</strong></u>
                <br/>
                • У стрелочных функций нет собственного контекста this. Они берут его из окружающего контекста, в
                котором были созданы.
                <br/>
                • Стрелочные функции не могут быть конструкторами (т.е. их нельзя использовать с new).
                <br/>
                • У стрелочных функций нет массива arguments. Вместо этого можно использовать rest-параметры.
                <br/>
                • this в стрелочных функциях определяется в момент их создания, а не в момент вызова. То есть стрелочные
                функции всегда используют this того места, где они были написаны.
                <br/>

            </>
    },
    {
        title: "8. Разница между === и ==?",
        description:
            <>
                🔸 == (нестрогое равенство)
                <br/>
                Сравнивает значения, но может автоматически менять типы.
                <br/>
                <br/>
                "5" == 5 // true — строка превращается в число
                <br/>
                true == 1 // true — true превращается в 1
                <br/>
                <br/>
                <br/>
                🔸 === (строгое равенство)
                <br/>
                Сравнивает и значения, и типы данных.
                <br/>
                Если типы разные — результат сразу false.
                <br/>
                <br/>
                "5" === 5 // false — строка и число не равны
                <br/>
                true === 1 // false — булевый тип и число разные
                <br/>
                5 === 5 // true — и тип, и значение совпадают
            </>
    },
    {
        title: "9. This в strict и в обычном режиме?",
        description:
            <>
                <p><strong>this</strong> — это ключевое слово в JavaScript, которое указывает на объект, в контексте
                    которого выполняется код.</p>
<br/>
                <p>🌍 <strong>В глобальной области (вне функций)</strong></p>

                <p>🔹 <strong>Обычный режим (без use strict)</strong></p>
                <pre><code>
console.log(this); // window (в браузере)
    </code></pre>
                <p>👉 this указывает на глобальный объект — в браузере это <code>window</code>.</p>
<br/>
                <p>🔸 <strong>Strict mode ('use strict')</strong></p>
                <pre><code>
'use strict';
console.log(this); // undefined
    </code></pre>
                <p>👉 this становится <code>undefined</code>, потому что в строгом режиме JavaScript запрещает
                    автоматически привязывать глобальный объект.</p>
<br/>
                <p>✅ <strong>В методах объекта (всегда одинаково)</strong></p>
                <pre><code>
{`const user = {
  name: 'Anna',
  showName() {
    console.log(this.name);
  }
};`}
                    user.showName(); // Anna
    </code></pre>
                <p>👉 Здесь this всегда указывает на объект <code>user</code>, вне зависимости от режима (strict или
                    нет).</p>
            </>
    },
    {
        title: "10. Что такое мемоизация и кеширование?",
        description:
            <>
                <p>🧠 Что такое Мемоизация (Memoization)</p>

                <p>Мемоизация — это частный случай кеширования, когда ты сохраняешь результат функции, чтобы не пересчитывать его при тех же входных данных.</p>

               <p> 📌 Используется в основном для оптимизации производительности функций.</p>
                <br/>
                <p>📌 Что такое Кеширование (Caching)</p>
                <p> Кеширование — это сохранение данных (или результатов операций) в быстром доступе, чтобы при повторном обращении не нужно было получать или вычислять их заново.</p>

               <p>🔧 Примеры:</p>
                <p>  •	Браузер сохраняет изображения и стили сайта (кеширует), чтобы не загружать их повторно при следующем визите.</p>
<p>•	Сайт сохраняет ответ от сервера в памяти, чтобы не делать повторный запрос, если данные уже есть.</p>
                <p>  •	React Query кеширует запросы к серверу, чтобы быстрее показывать данные.</p>

            </>
    },
    {
        title: "11. Откуда у примитивов методы, автобоксинг?",
        description:
            <>
                <p>Каждый примитив имеет собственный объект-обёртку, которые называются: String, Number, Boolean, Symbol
                    и BigInt.</p>
                <p>А прототипы этих обьектов уже имеют разный набор методов. </p>
                <p>И вот когда происходит обращение к какому-то методу у примитива, он автоматически оборачивается в
                    обьект-обертку, этот механизм называется Autoboxing</p>

            </>
    },
    {
        title: "?",
        description:
            <>

            </>
    }
];

function App() {
    const [activeHtmlIndex, setActiveHtmlIndex] = useState({})
    const [activeCssIndex, setActiveCssIndex] = useState({})
    const [activeJsIndex, setActiveJsIndex] = useState({})


    function toggleArrowHtml(item) {
        setActiveHtmlIndex((prev) => ({
            ...prev,
            [item]: !prev[item]
        }))
    }

    function toggleArrowCss(item) {
        setActiveCssIndex((prev) => ({
            ...prev,
            [item]: !prev[item]
        }))
    }


    function toggleArrowJs(item) {
        setActiveJsIndex((prev) => ({
            ...prev,
            [item]: !prev[item]
        }))
    }

    return (
        <>
            <QuestionsSection title={'HTML'} question={questionHtml} toggleArrow={toggleArrowHtml}
                              activeIndex={activeHtmlIndex}/>
            <QuestionsSection title={'CSS'} question={questionCss} toggleArrow={toggleArrowCss}
                              activeIndex={activeCssIndex}/>
            <QuestionsSection title={'JS'} question={questionJs} toggleArrow={toggleArrowJs}
                              activeIndex={activeJsIndex}/>
        </>
    )
}


export default App



