import React, {useState} from 'react'

import './App.css'
import {QuestionsSection} from "./components/QuestionsSection.jsx";
import {Form} from "./components/Form.jsx";

const questionHtml = [
    {
        title: "1. Расскажите как работает браузер? ",
        description:
            <>
                Браузер - это программное обеспечение, которое позволяет пользователям просматривать и взаимодействовать
                с веб-страницами. Вот основные шаги, которые браузер выполняет для отображения веб-страницы:
                <br/>
                <br/>
                1. <u><strong>Ввод URL:</strong></u> Пользователь вводит URL (Uniform Resource Locator) в адресную
                строку браузера. URL указывает на веб-страницы, которую пользователь хочет посетить.
                <br/>
                <br/>
                2. <u><strong>Хост файлы на компьютере.</strong></u> Если ранее уже были запросы. Вернет Айпи уже,
                который знает.
                <br/>
                <br/>
                3. <u><strong>DNS-запрос:</strong></u> Браузер отправляет DNS-запрос (Domain Name System) на DNS-сервер,
                чтобы получить IP-сервера, на котором храниться веб-страница. DNS-сервер преобразует доменное имя
                (например, www.example.com) в соответствующий IP-адрес.
                <br/>
                <br/>
                4. <u><strong> Установка соединения:</strong></u> Браузер устанавливает ТСР-соединение с сервером,
                используя полученный IP-адрес. Это позволяет браузеру отправлять и получать данные с сервера.
                <br/>
                <br/>
                5. <u><strong> Запрос страницы:</strong></u> Браузер отправляет HTTP-запрос (Hypertext Transfer
                Protocol) на сервер, запрашивая веб-страницу. Запрос может содержать различные параметры, такие как
                методы запроса (GET, POST и т. д.) заголовки и тело запроса.
                <br/>
                <br/>
                6. <u><strong> Получение ответа: </strong></u> Сервер обрабатывает запрос и отправляет обратно
                HTTP-ответ, содержащий запрошенную веб-страницу. Ответ может так же содержать различные заголовки,
                статус ответа и тело ответа. Браузер анализирует заголовки ответа. Заголовки могут содержать важную
                информацию, такую как тип контента (Content-Type), правила кеширования и т.д.
                <br/>
                <br/>
                7. <u><strong>Рендеринг страницы:</strong></u> Браузер получает ответ от сервера и начинает обрабатывать
                его. Он анализирует HTML-код страницы, строит DOM (Document Object Model) - внутреннее представление
                страницы, и создает дерево элементов.
                <br/>
                <br/>
                8. <u><strong> Загрузка ресурсов:</strong></u> Браузер загружает все связанные ресурсы, такие как
                изображения, стили CSS, скрипты JavaScript и другие файлы, указанные в HTML-коде страницы.
                <br/>
                <br/>
                9. <u><strong>Отображение страницы:</strong></u> Браузер использует полученные ресурсы и информацию о
                стилях для отображения страницы на экране. Он располагает элементы в соответствии с их CSS-свойствами,
                применяет шрифты, цвета и другие стили, и отображает содержимое страницы.
            </>,

    },
    {
        title: "2. Какие есть этапы рендеринга html страницы?",
        description:
            <>
                1. Парсинг HTML
                <br/>
                + Браузер начинает парсить HTML-документ и строить DOM-дерево (Document Object Model), представляющее
                иерархическую структуру всех элементов страницы.
                <br/>
                + Если браузер находит <code>&lt;script&gt;</code>, он приостанавливает парсинг, загружает и выполняет
                скрипт, что может изменить структуру DOM.
                <br/>
                <br/>
                2. Загрузка внешних ресурсов
                <br/>
                +Во время парсинга HTML браузер обнаруживает ссылки на внешние ресурсы (СSS, изображения, шрифты,
                скрипты) и начинает их загружать параллельно.
                <br/>
                + CSS загружается и парсится, формируя CSSOM (CSS Object Model).
                <br/>
                <br/>
                3. Построение рендер-дерева
                <br/>
                + DOM и CSSOM обьединяются для создания рендер-дерева, которое представляет собой структуру элементов,
                подлежащих отображению на экране с примененными стилями.
                <br/>
                <br/>
                4. Вычисление гиометрии (Layout)
                <br/>
                + Браузер вычисляет размеры и приложения каждого элемента на странице, основываясь на рендер-дереве.
                Этот процесс называется layout или reflow.
                <br/>
                <br/>
                5 Отрисовка (Painting)
                <br/>
                Браузер преобразует рендер-дерево в пиксели на экране, рисуя текст, цвета, изображения, тени и другие
                графические элементы.
                <br/>
                <br/>
                6. Композиция (Compositing)
                <br/>
                Некоторые элементы могут быть отрисованы в отдельных слоях для улучшения производительности(например
                анимация или фиксированные элементы). На этапе композиции браузер объединяет эти слои в одно изображение
                для отображения на экране.
                <br/>
                <br/>
                7. Интерфейс пользователя (UI)
                <br/>
                +Браузер обрабатывает пользовательские события(клики, прокрутки, ввод данных и т д)
                <br/>
                + JavaScript может изменять DOM, что может запустить повторные этапы layout и painting.
            </>,
    },
]

const questionCss = [
    {
        title: "1. В чем разница между box-sizing: content-box и box-sizing: border-box?",
        description:
            <>
                <u><strong> box-sizing: content-box </strong></u> Размер элемента считается только по содержимому
                (content).
                Ширина и высота не включают в себя padding (внутренние отступы) и border (границы).
                Их нужно прибавлять отдельно, поэтому итоговый размер элемента будет больше, чем указано..
                <br/>
                <br/>
                <u><strong> box-sizing: border-box </strong></u> Размер элемента включает в себя и content, и padding, и
                border.
                То есть, общая ширина и высота элемента остаются фиксированными, и отступы/границы просто уменьшают
                область для содержимого.
                Удобно при адаптивной вёрстке, потому что проще управлять размерами блоков.


            </>
    }
]

const questionJs = [
    {
        title: "1. Как узнать какого типа переменная? Что и в каком виде возвращает typeof",
        description: (
            <>
                Оператор <u><strong>typeof</strong></u> возвращает тип аргумента. Это полезно, когда мы хотим обработать
                значения разных типов по-разному или просто хотим сделать проверку.
                <br/>
                У него есть 2 синтаксические формы:
                <br/>
                <br/>
                //Обычный синтаксис
                <br/>
                typeof 5 // Выведет 'number'
                <br/>
                <br/>
                //Синтаксис, напоминающий вызов функции. Встречается реже.
                <br/>
                typeof (5) // Выведет 'number'
                <br/>
                <br/>
                Если передается выражение, то нужно заключать его в скобки, тк <u><strong>typeof</strong></u> имеет
                более высокий приоритет, чем бинарные операторы. Другими словами, скобки необходимы для определения типа
                значения, которое получилось в результате выполнения выражения в них.
                <br/>
                <br/>
                typeof 50 + ' Квартир'; // Выведет 'number Квартир'
                <br/>
                typeof (50 + ' Квартир'); // Выведет 'string'
            </>

        ),
    },
    {
        title: "2. Зачем для тега <script> добавляют атрибуты async и defer?",
        description: (
            <>
                Без использования атрибутов в теге <strong>&lt;script&gt;</strong>, когда браузер загружает HTML и
                доходит до тега <strong>&lt;script&gt;</strong>,
                то он может дальше строить DOM, пока не выполнит скрипт. Соответственно потребуется больше времени для
                того, чтобы показать пользователю готовую страницу. <br/>
                Для решения этой проблемы тег <strong>&lt;script&gt;</strong> можно поместить в конец страницы. Но это
                не идеальное решение, так как выполнение скрипта может начаться с сильной задержкой. Для этого есть
                атрибуты:
                <br/><br/>
                <u><strong>async:</strong></u> Свойство async для тега <strong>&lt;script&gt;</strong> указывает
                браузеру загружать скрипт асинхронно, не блокируя последующий парсинг HTML или выполнение других
                скриптов на странице. <br/>
                Скрипт с атрибутом async загружается параллельно с парсингом HTML и выполняется сразу после завершения
                загрузки. Порядок выполнения скриптов не гарантируется. <br/>
                Подходит для скриптов, которые не зависят от других ресурсов на странице и могут быть выполнены
                независимо от них. <br/><br/>
                <u><strong>defer:</strong></u> Свойство defer для тега <strong>&lt;script&gt;</strong> говорит браузеру
                загружать скрипт асинхронно, но откладывать его выполнение до завершения парсинга HTML. <br/>
                Скрипты с атрибутом defer загружаются параллельно с парсингом HTML, но их выполнение откладывается до
                завершения парсинга. Они выполняются в том порядке, в котором указаны в HTML, перед событием
                DOMContentLoaded. <br/>
                Использование async и defer помогает ускорить загрузку страницы, улучшить воспроизводимость скриптов и
                повысить производительность веб-страницы.
            </>
        ),
    },
    {
        title: "3. Что такое замыкания в JS и почему они важны?",
        description: "Замыкания в JS - это функция, которая запоминает свое окружение во время создания и может использовать переменные из этого окружения даже после того, как это окружение прекратило свое существование. Они важны, потому что позволяют создавать приватные переменные, сохранять состояние и делать код более модульным.",
    },
    {
        title: "4. Что такое NaN? Какого типа это значения? Как можно узнать, равно ли значение переменной NaN?",
        description:
            <>
                NaN означает 'Not-A-Number' и является специальным значением в JS, которое указывает на ошибку при
                выполнении математических операций, когда результат не является числом. Тип значения NaN в JS - это
                число (Number).
                <br/>
                Чтобы проверить,равно ли значение переменной NaN, можно использовать функцию isNaN(). Например:
                <br/>
                <br/>
                let result = 10 / 'привет'; <br/>
                console.log(isNaN(result)); // Вернет true, т к результат деления не является числом
            </>
    },
    {
        title: "5. Какие бинарные операторы вы знаете?",
        description:

            <>
                Бинарные операторы работают с двумя операндами.
                <br/><br/>
                <strong>1. Арифметические (Используются для выполнения математических операций.): </strong>
                <br/>
                <code>(+)</code> — сложение: <code>a + b</code><br/>
                <code>(-)</code> — вычитание: <code>a - b</code><br/>
                <code>(*)</code> — умножение: <code>a * b</code><br/>
                <code>(/)</code> — деление: <code>a / b</code><br/>
                <code>(%)</code> — остаток от деления: <code>a % b</code><br/>
                <code>(**)</code> — возведение в степень: <code>a ** b</code>
                <br/><br/>
                <strong>2. Операторы сравнения (Используются для сравнения двух значений.):</strong>
                <br/>
                <code>(==)</code> — нестрогое равенство<br/>
                <code>(!=)</code> — нестрогое неравенство<br/>
                <code>(===)</code> — строгое равенство<br/>
                <code>(!==)</code> — строгое неравенство<br/>
                <code>(&gt;)</code> — больше<br/>
                <code>(&lt;)</code> — меньше<br/>
                <code>(&gt;=)</code> — больше или равно<br/>
                <code>(&lt;=)</code> — меньше или равно
                <br/><br/>
                <strong>3. Логические (Используются для выполнения логических операций.):</strong>
                <br/>
                <code>(&&)</code> — логическое И<br/>
                <code>(||)</code> — логическое ИЛИ
            </>
    },
    {
        title: "6. Отличие null и undefined?",
        description:
            <>
                null явно указывает на отсутствие значения или пустое состояние. Это как бы “нуль” для объектов.
                <br/>
                null обычно используется для обозначения пустой или несуществующей ссылки на объект.
                <br/>
                undefined означает, что переменная была объявлена, но ей еще не присвоено значение.
                Это значение по умолчанию для необъявленных или неинициализированных переменных.
                <br/>
                Undefined не равен ничему кроме себя, но null == undefined;
                <br/>
                <br/>
                typeof null === “object” а typeof undefined === ‘undefined’
            </>,
    },
    {
        title: "7. Отличия межу arrow function (Стрелочные функции)  function declaration  function expression?",
        description:
            <>
                <u><strong>Function Declaration</strong></u> создается до выполнения кода, так что ее можно вызвать до
                того, как она была написана. this зависит от контекста, в котором функция вызвана.
                <br/>
                <u><strong>Function Expression</strong></u> - Функции, присвоенные переменной, как правило, не имеют
                имени и их нельзя вызвать до того, как они были определены.
                <br/>
                Declaration – function sum(a,b){};
                <br/>
                Expression – const sum = function (a,b){}
                <br/>

                <u><strong> Arrow Functions (Стрелочные функции)</strong></u>
                <br/>
                • У стрелочных функций нет собственного контекста this. Они берут его из окружающего контекста, в
                котором были созданы.
                <br/>
                • Стрелочные функции не могут быть конструкторами (т.е. их нельзя использовать с new).
                <br/>
                • У стрелочных функций нет массива arguments. Вместо этого можно использовать rest-параметры.
                <br/>
                • this в стрелочных функциях определяется в момент их создания, а не в момент вызова. То есть стрелочные
                функции всегда используют this того места, где они были написаны.
                <br/>

            </>
    },
    {
        title: "8. Разница между === и ==?",
        description:
            <>
                🔸 == (нестрогое равенство)
                <br/>
                Сравнивает значения, но может автоматически менять типы.
                <br/>
                <br/>
                "5" == 5 // true — строка превращается в число
                <br/>
                true == 1 // true — true превращается в 1
                <br/>
                <br/>
                <br/>
                🔸 === (строгое равенство)
                <br/>
                Сравнивает и значения, и типы данных.
                <br/>
                Если типы разные — результат сразу false.
                <br/>
                <br/>
                "5" === 5 // false — строка и число не равны
                <br/>
                true === 1 // false — булевый тип и число разные
                <br/>
                5 === 5 // true — и тип, и значение совпадают
            </>
    },
    {
        title: "9. This в strict и в обычном режиме?",
        description:
            <>
                <p><strong>this</strong> — это ключевое слово в JavaScript, которое указывает на объект, в контексте
                    которого выполняется код.</p>
                <br/>
                <p>🌍 <strong>В глобальной области (вне функций)</strong></p>

                <p>🔹 <strong>Обычный режим (без use strict)</strong></p>
                <pre><code>
console.log(this); // window (в браузере)
    </code></pre>
                <p>👉 this указывает на глобальный объект — в браузере это <code>window</code>.</p>
                <br/>
                <p>🔸 <strong>Strict mode ('use strict')</strong></p>
                <pre><code>
'use strict';
console.log(this); // undefined
    </code></pre>
                <p>👉 this становится <code>undefined</code>, потому что в строгом режиме JavaScript запрещает
                    автоматически привязывать глобальный объект.</p>
                <br/>
                <p>✅ <strong>В методах объекта (всегда одинаково)</strong></p>
                <pre><code>
{`const user = {
  name: 'Anna',
  showName() {
    console.log(this.name);
  }
};`}
                    user.showName(); // Anna
    </code></pre>
                <p>👉 Здесь this всегда указывает на объект <code>user</code>, вне зависимости от режима (strict или
                    нет).</p>
            </>
    },
    {
        title: "10. Что такое мемоизация и кеширование?",
        description:
            <>
                <p>🧠 Что такое Мемоизация (Memoization)</p>

                <p>Мемоизация — это частный случай кеширования, когда ты сохраняешь результат функции, чтобы не
                    пересчитывать его при тех же входных данных.</p>

                <p> 📌 Используется в основном для оптимизации производительности функций.</p>
                <br/>
                <p>📌 Что такое Кеширование (Caching)</p>
                <p> Кеширование — это сохранение данных (или результатов операций) в быстром доступе, чтобы при
                    повторном обращении не нужно было получать или вычислять их заново.</p>

                <p>🔧 Примеры:</p>
                <p> • Браузер сохраняет изображения и стили сайта (кеширует), чтобы не загружать их повторно при
                    следующем визите.</p>
                <p>• Сайт сохраняет ответ от сервера в памяти, чтобы не делать повторный запрос, если данные уже
                    есть.</p>
                <p> • React Query кеширует запросы к серверу, чтобы быстрее показывать данные.</p>

            </>
    },
    {
        title: "11. Откуда у примитивов методы, автобоксинг?",
        description:
            <>
                <p>Каждый примитив имеет собственный объект-обёртку, которые называются: String, Number, Boolean, Symbol
                    и BigInt.</p>
                <p>А прототипы этих обьектов уже имеют разный набор методов. </p>
                <p>И вот когда происходит обращение к какому-то методу у примитива, он автоматически оборачивается в
                    обьект-обертку, этот механизм называется Autoboxing</p>
                <br/>
                <p>Когда ты обращаешься к методу примитива, JavaScript на время делает такую “магическую” штуку:</p>
                <p>"hello".toUpperCase()</p>
                <p>Вот что реально происходит внутри:</p>
                <p>new String("hello").toUpperCase()</p>
                <p>То есть:</p>
                <p> 1. JavaScript берёт "hello" и оборачивает его во временный объект String.</p>
                <p> 2. У объекта String есть метод toUpperCase().</p>
                <p> 3. Выполняется метод.</p>
                <p> 4. Потом объект удаляется, и ты получаешь результат.</p>


            </>
    },
    {
        title: "12. Почему typeof массива === object?",
        description:
            <>
                <p> • Массив создаётся с помощью конструктора new Array().</p>
                <p> • Он наследует все свойства и методы от Array.prototype.</p>
                <p> • А Array.prototype, в свою очередь, наследует от Object.prototype.</p>
                <p>То есть массив — это обычный объект, просто у него есть дополнительные “фишки” для работы с
                    элементами по индексам: push, pop, length и т.д.</p>
                <p>✅ Потому что массив — это объект с номерами вместо ключей:</p>
                <pre>
<code>{`{
  0: 1,
  1: 2,
  2: 3,
  length: 3
}`}</code>
</pre>
                <p>Массивы в JavaScript — это объекты, просто они умеют работать с числами как с индексами и имеют
                    методы для удобной работы с элементами.</p>

            </>
    },
    {
        title: "13 Что такое Set??",
        description:
            <>
                <p>Set — это специальный тип коллекции в JavaScript, в котором не может быть одинаковых значений.</p>
                <p>💡 Представь:</p>
                <p>Это как коробка, куда ты кладёшь вещи. Но если ты попробуешь положить одинаковую вещь второй раз — коробка её просто не примет.</p>
               <br/>
                <p>🔹 Основные особенности:</p>
                <p>	✅1.	Только уникальные значения</p>
                <pre>
                    <code>
                        {
                            `
const set = new Set();
set.add(1);
set.add(1); // не добавится снова
set.add(2);
console.log(set); // Set { 1, 2 }
                            `
                        }
                    </code>
                </pre>
                <p>	✅2	Любой тип данных</p>
                   <p> Ты можешь хранить и числа, и строки, и объекты:</p>
                <pre>
                    <code>
                        {
                            `set.add('hello');
set.add({name: 'John'});`
                        }
                    </code>
                </pre>
                <br/>
                <p>	✅3.Без индексов</p>
                <p>У Set нет индексов, как в массиве. Нельзя обратиться к элементу по номеру.</p>
                <p>add(value) - Добавляет значение в коллекцию</p>
                <p>delete(value) - Удаляет значение</p>
                <p>has(value) - Проверяет есть ли значение</p>
                <p>clear() - Очищает весь Set</p>
                <p>size - Показывает сколько значений в Set</p>
                <p>forEach() - Позволяет пройтись по значениям</p>
                <p>values() - Возвращает обьект итератор значений</p>
            </>
    },
    {
        title: "14 Что такое Map?",
        description:
            <>
                <p>Map — это специальная коллекция в JavaScript, которая хранит пары ключ → значение.</p>
                <p>🤔 Чем отличается от обычного объекта?</p>
                 <u><strong>Map:</strong></u>
                <p>✅ Ключом может быть что угодно - строка, обьект, массив, функция и т.д.</p>
                <p>✅Содержит только то, что ты сам добавил</p>
                <p>✅ Можно легко перебирать(map.entries().map.keys(),map.values())</p>
                 <u><strong>Object:</strong></u>
                <p>✅ Ключ - только строка или символ</p>
                <p>✅ Наследует свойства от прототипа (например, toString</p>
                <p>✅Нужно использовать for...in, Object.keys() и т.д</p>
                <br/>
                <u><strong>🔧 Полезные методы Map:</strong></u>
                <p>set(key, value) - добавляет значение по ключу</p>
                <p>get(key) - получает значение по ключу</p>
                <p>has(key) - проверяет, есть ли ключ</p>
                <p>delete(key) - удаляет запись по ключу</p>
                <p>clear() - очищает весь Map</p>
                <p>keys() - возвращает все ключи</p>
                <p>values() - возвращает все значения</p>
                <p>entries() - возвращает массив [ключ, значение]</p>
            </>
    },
    {
        title: "15. Что такое WeakMap отличия от Map?",
        description:
            <>
                <p>В отличии от Map в WeakMap:</p>
                <p>✅ ключи должны быть ссылочного типа (обьект, массив), а не примитивные значениями</p>
                <p>✅ если мы используем обьект в качестве ключа и на этот обьект нет ссылок, то он будет удален из памяти сборщиком мусора.</p>
                <p>✅ WeakMap не поддерживает перебор и методы keys(), values(), entries(), так что нет способа взять все ключи или значения из нее.</p>
            </>
    },
    {
        title: "16. Что такое WeakSet?",
        description:
            <>
                <p>WeakSet — это специальная коллекция, которая хранит только объекты (не строки, не числа).</p>
                <br/>
                <p>	1.	✅ Можно добавлять только объекты:</p>
                <pre>
<code>{`
    const ws = new WeakSet();
    ws.add({name: "Alex"}); // ок
    ws.add(123); // ❌ ошибка — нельзя добавлять числа
`}
</code>
</pre>
                <br/>
                <p>	2.	♻️ Если на объект больше нет ссылок, он автоматически удаляется из памяти:</p>
                <p>	•	Это помогает экономить память.</p>
                <br/>
                <p>	3.	❌ Нельзя перебрать WeakSet:</p>
                <p>•	Нельзя использовать for...of, size, keys(), values(), entries() — всё это не работает.</p>
                <p>📌 Зачем нужен?</p>
                <p>WeakSet полезен, когда тебе нужно просто отмечать объекты, без перебора, и не хранить их вечно, если они больше не нужны.</p>

            </>
    },
    {
        title: "17. Типы данных в JS?",
        description:
            <>
                <p>В JavaScript есть 8 основных (примитивных и не только) типов данных:</p>
                <p> 👉	1. 	Number – числа (Примеры: 5, 3.14, -10)</p>
                <p> 👉	2.	String – строки (Примеры: "Привет", 'Мир', `Шаблонная строка`)</p>
                <p> 👉	3.	Boolean – логический тип Значения: true или false ({`Пример:  5 > 3`} // true)</p>
                <p> 👉	4.	Null – “пусто”, “ничего” (Пример: let a = null);</p>
                <p> 👉	5.	Undefined – значение не присвоено (Пример: {`
                let x;
                console.log(x); // undefined`})</p>
                <p> 👉	6.	Symbol – уникальный идентификатор (редко используется)
                    <br/>
                    (Пример: let id = Symbol("id");)</p>
                <p> 👉	7.	BigInt – большие числа (больше, чем Number.MAX_SAFE_INTEGER)
                    <br/>
                   ( Пример: const big = 123456789012345678901234567890n)</p>
                <p>🧱 Сложный тип:</p>
                  <p> 👉  8.	Object – объекты, массивы, функции и т.д.</p>

            </>
    },

    {
        title: "18. Зачем нужен Метод PreventDefault?",
        description:
            <>
                <p>🚦 Что такое preventDefault()</p>
                <p>Когда в браузере происходит какое-то событие (например, нажатие кнопки, отправка формы, клик по ссылке), у этого события есть действие по умолчанию.</p>
                <p>Примеры действий по умолчанию:</p>
                <p>	•	При отправке формы (submit) — страница перезагружается.</p>
                <p>	•	При клике на ссылку ({`<a href="..."`}) — браузер переходит на другой сайт.</p>
                <p>	•	При перетаскивании файла — браузер пытается открыть файл.</p>
                <br/>
                <p>Иногда мы не хотим, чтобы происходило это стандартное поведение.</p>
                <p>🎯 Для чего нужен preventDefault()</p>
                <p>Метод preventDefault() отменяет стандартное действие браузера.</p>
                <p>То есть:
                    Событие произойдёт, но браузер не сделает то, что делает обычно.</p>
                <br/>
                <pre>
                    <code>
                     {
                         `function handleSubmit(event) {
event.preventDefault(); // ⛔ Останавливаем стандартное поведение (перезагрузку страницы)
 console.log('Форма отправлена, но страница не перезагрузилась!');
               }`}
                    </code>
                </pre>
                <br/>
                <p>Без preventDefault():</p>
                <p>	•	Нажимаешь кнопку формы → Страница перезагружается → Все данные в форме теряются.</p>
                <p>С preventDefault():</p>
                <p>	•	Нажимаешь кнопку → Нет перезагрузки → Мы сами решаем, что делать дальше (например, сохранить данные).
                </p>
                <p>🧠 И ещё важно:</p>
                <p>	•	preventDefault() останавливает только стандартное поведение.</p>
                <p>	•	Само событие (например, клик) продолжает происходить и может передаваться дальше.</p>

            </>
    },
    {
        title: "?",
        description:
            <>

            </>
    },
];

function App() {
    const [activeHtmlIndex, setActiveHtmlIndex] = useState({})
    const [activeCssIndex, setActiveCssIndex] = useState({})
    const [activeJsIndex, setActiveJsIndex] = useState({})
    const [search, setSearch] = useState('')

    const filterHtmlQuestions = search
    ? questionHtml.filter(q => q.title.toLowerCase().includes(search.toLowerCase()))
        : questionHtml

    const filterCssQuestions = search
    ? questionCss.filter(q => q.title.toLowerCase().includes(search.toLowerCase()))
        : questionCss

    const filterJsQuestion = search
    ?  questionJs.filter(q => q.title.toLowerCase().includes(search.toLowerCase()))
        : questionJs


        function toggleArrowHtml(item) {
        setActiveHtmlIndex((prev) => ({
            ...prev,
            [item]: !prev[item]
        }))
    }

    function toggleArrowCss(item) {
        setActiveCssIndex((prev) => ({
            ...prev,
            [item]: !prev[item]
        }))
    }


    function toggleArrowJs(item) {
        setActiveJsIndex((prev) => ({
            ...prev,
            [item]: !prev[item]
        }))
    }

    return (
        <>
            <form action="">
                <input type="search"
                       placeholder='Поиск по названию вопроса'
                       value={search}
                       onChange={(e) => setSearch(e.target.value)}
                />
                <button type="submit" className='button-form'>🔍</button>
            </form>
            <QuestionsSection title={'HTML'} question={filterHtmlQuestions} toggleArrow={toggleArrowHtml}
                              activeIndex={activeHtmlIndex}/>
            <QuestionsSection title={'CSS'} question={filterCssQuestions} toggleArrow={toggleArrowCss}
                              activeIndex={activeCssIndex}/>
            <QuestionsSection title={'JS'} question={filterJsQuestion} toggleArrow={toggleArrowJs}
                              activeIndex={activeJsIndex}/>
        </>
    )
}


export default App



