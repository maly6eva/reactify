import React, {useState} from 'react'

import './App.css'
import {QuestionsSection} from "./components/QuestionsSection.jsx";
import {Form} from "./components/Form.jsx";

const questionHtml = [
    {
        title: "1. Расскажите как работает браузер? ",
        description:
            <>
                Браузер - это программное обеспечение, которое позволяет пользователям просматривать и взаимодействовать
                с веб-страницами. Вот основные шаги, которые браузер выполняет для отображения веб-страницы:
                <br/>
                <br/>
                1. <u><strong>Ввод URL:</strong></u> Пользователь вводит URL (Uniform Resource Locator) в адресную
                строку браузера. URL указывает на веб-страницы, которую пользователь хочет посетить.
                <br/>
                <br/>
                2. <u><strong>Хост файлы на компьютере.</strong></u> Если ранее уже были запросы. Вернет Айпи уже,
                который знает.
                <br/>
                <br/>
                3. <u><strong>DNS-запрос:</strong></u> Браузер отправляет DNS-запрос (Domain Name System) на DNS-сервер,
                чтобы получить IP-сервера, на котором храниться веб-страница. DNS-сервер преобразует доменное имя
                (например, www.example.com) в соответствующий IP-адрес.
                <br/>
                <br/>
                4. <u><strong> Установка соединения:</strong></u> Браузер устанавливает ТСР-соединение с сервером,
                используя полученный IP-адрес. Это позволяет браузеру отправлять и получать данные с сервера.
                <br/>
                <br/>
                5. <u><strong> Запрос страницы:</strong></u> Браузер отправляет HTTP-запрос (Hypertext Transfer
                Protocol) на сервер, запрашивая веб-страницу. Запрос может содержать различные параметры, такие как
                методы запроса (GET, POST и т. д.) заголовки и тело запроса.
                <br/>
                <br/>
                6. <u><strong> Получение ответа: </strong></u> Сервер обрабатывает запрос и отправляет обратно
                HTTP-ответ, содержащий запрошенную веб-страницу. Ответ может так же содержать различные заголовки,
                статус ответа и тело ответа. Браузер анализирует заголовки ответа. Заголовки могут содержать важную
                информацию, такую как тип контента (Content-Type), правила кеширования и т.д.
                <br/>
                <br/>
                7. <u><strong>Рендеринг страницы:</strong></u> Браузер получает ответ от сервера и начинает обрабатывать
                его. Он анализирует HTML-код страницы, строит DOM (Document Object Model) - внутреннее представление
                страницы, и создает дерево элементов.
                <br/>
                <br/>
                8. <u><strong> Загрузка ресурсов:</strong></u> Браузер загружает все связанные ресурсы, такие как
                изображения, стили CSS, скрипты JavaScript и другие файлы, указанные в HTML-коде страницы.
                <br/>
                <br/>
                9. <u><strong>Отображение страницы:</strong></u> Браузер использует полученные ресурсы и информацию о
                стилях для отображения страницы на экране. Он располагает элементы в соответствии с их CSS-свойствами,
                применяет шрифты, цвета и другие стили, и отображает содержимое страницы.
            </>,

    },
    {
        title: "2. Какие есть этапы рендеринга html страницы?",
        description:
            <>
                1. Парсинг HTML
                <br/>
                + Браузер начинает парсить HTML-документ и строить DOM-дерево (Document Object Model), представляющее
                иерархическую структуру всех элементов страницы.
                <br/>
                + Если браузер находит <code>&lt;script&gt;</code>, он приостанавливает парсинг, загружает и выполняет
                скрипт, что может изменить структуру DOM.
                <br/>
                <br/>
                2. Загрузка внешних ресурсов
                <br/>
                +Во время парсинга HTML браузер обнаруживает ссылки на внешние ресурсы (СSS, изображения, шрифты,
                скрипты) и начинает их загружать параллельно.
                <br/>
                + CSS загружается и парсится, формируя CSSOM (CSS Object Model).
                <br/>
                <br/>
                3. Построение рендер-дерева
                <br/>
                + DOM и CSSOM обьединяются для создания рендер-дерева, которое представляет собой структуру элементов,
                подлежащих отображению на экране с примененными стилями.
                <br/>
                <br/>
                4. Вычисление гиометрии (Layout)
                <br/>
                + Браузер вычисляет размеры и приложения каждого элемента на странице, основываясь на рендер-дереве.
                Этот процесс называется layout или reflow.
                <br/>
                <br/>
                5 Отрисовка (Painting)
                <br/>
                Браузер преобразует рендер-дерево в пиксели на экране, рисуя текст, цвета, изображения, тени и другие
                графические элементы.
                <br/>
                <br/>
                6. Композиция (Compositing)
                <br/>
                Некоторые элементы могут быть отрисованы в отдельных слоях для улучшения производительности(например
                анимация или фиксированные элементы). На этапе композиции браузер объединяет эти слои в одно изображение
                для отображения на экране.
                <br/>
                <br/>
                7. Интерфейс пользователя (UI)
                <br/>
                +Браузер обрабатывает пользовательские события(клики, прокрутки, ввод данных и т д)
                <br/>
                + JavaScript может изменять DOM, что может запустить повторные этапы layout и painting.
            </>,
    },
]

const questionCss = [
    {
        title: "1. В чем разница между box-sizing: content-box и box-sizing: border-box?",
        description:
            <>
                <u><strong> box-sizing: content-box </strong></u> Размер элемента считается только по содержимому
                (content).
                Ширина и высота не включают в себя padding (внутренние отступы) и border (границы).
                Их нужно прибавлять отдельно, поэтому итоговый размер элемента будет больше, чем указано..
                <br/>
                <br/>
                <u><strong> box-sizing: border-box </strong></u> Размер элемента включает в себя и content, и padding, и
                border.
                То есть, общая ширина и высота элемента остаются фиксированными, и отступы/границы просто уменьшают
                область для содержимого.
                Удобно при адаптивной вёрстке, потому что проще управлять размерами блоков.


            </>
    }
]

const questionJs = [
    {
        title: "1. Как узнать какого типа переменная? Что и в каком виде возвращает typeof",
        description: (
            <>
                Оператор <u><strong>typeof</strong></u> возвращает тип аргумента. Это полезно, когда мы хотим обработать
                значения разных типов по-разному или просто хотим сделать проверку.
                <br/>
                У него есть 2 синтаксические формы:
                <br/>
                <br/>
                //Обычный синтаксис
                <br/>
                typeof 5 // Выведет 'number'
                <br/>
                <br/>
                //Синтаксис, напоминающий вызов функции. Встречается реже.
                <br/>
                typeof (5) // Выведет 'number'
                <br/>
                <br/>
                Если передается выражение, то нужно заключать его в скобки, тк <u><strong>typeof</strong></u> имеет
                более высокий приоритет, чем бинарные операторы. Другими словами, скобки необходимы для определения типа
                значения, которое получилось в результате выполнения выражения в них.
                <br/>
                <br/>
                typeof 50 + ' Квартир'; // Выведет 'number Квартир'
                <br/>
                typeof (50 + ' Квартир'); // Выведет 'string'
            </>

        ),
    },
    {
        title: "2. Зачем для тега <script> добавляют атрибуты async и defer?",
        description: (
            <>
                Без использования атрибутов в теге <strong>&lt;script&gt;</strong>, когда браузер загружает HTML и
                доходит до тега <strong>&lt;script&gt;</strong>,
                то он может дальше строить DOM, пока не выполнит скрипт. Соответственно потребуется больше времени для
                того, чтобы показать пользователю готовую страницу. <br/>
                Для решения этой проблемы тег <strong>&lt;script&gt;</strong> можно поместить в конец страницы. Но это
                не идеальное решение, так как выполнение скрипта может начаться с сильной задержкой. Для этого есть
                атрибуты:
                <br/><br/>
                <u><strong>async:</strong></u> Свойство async для тега <strong>&lt;script&gt;</strong> указывает
                браузеру загружать скрипт асинхронно, не блокируя последующий парсинг HTML или выполнение других
                скриптов на странице. <br/>
                Скрипт с атрибутом async загружается параллельно с парсингом HTML и выполняется сразу после завершения
                загрузки. Порядок выполнения скриптов не гарантируется. <br/>
                Подходит для скриптов, которые не зависят от других ресурсов на странице и могут быть выполнены
                независимо от них. <br/><br/>
                <u><strong>defer:</strong></u> Свойство defer для тега <strong>&lt;script&gt;</strong> говорит браузеру
                загружать скрипт асинхронно, но откладывать его выполнение до завершения парсинга HTML. <br/>
                Скрипты с атрибутом defer загружаются параллельно с парсингом HTML, но их выполнение откладывается до
                завершения парсинга. Они выполняются в том порядке, в котором указаны в HTML, перед событием
                DOMContentLoaded. <br/>
                Использование async и defer помогает ускорить загрузку страницы, улучшить воспроизводимость скриптов и
                повысить производительность веб-страницы.
            </>
        ),
    },
    {
        title: "3. Что такое замыкания в JS и почему они важны?",
        description: "Замыкания в JS - это функция, которая запоминает свое окружение во время создания и может использовать переменные из этого окружения даже после того, как это окружение прекратило свое существование. Они важны, потому что позволяют создавать приватные переменные, сохранять состояние и делать код более модульным.",
    },
    {
        title: "4. Что такое NaN? Какого типа это значения? Как можно узнать, равно ли значение переменной NaN?",
        description:
            <>
                NaN означает 'Not-A-Number' и является специальным значением в JS, которое указывает на ошибку при
                выполнении математических операций, когда результат не является числом. Тип значения NaN в JS - это
                число (Number).
                <br/>
                Чтобы проверить,равно ли значение переменной NaN, можно использовать функцию isNaN(). Например:
                <br/>
                <br/>
                let result = 10 / 'привет'; <br/>
                console.log(isNaN(result)); // Вернет true, т к результат деления не является числом
            </>
    },
    {
        title: "5. Какие бинарные операторы вы знаете?",
        description:

            <>
                Бинарные операторы работают с двумя операндами.
                <br/><br/>
                <strong>1. Арифметические (Используются для выполнения математических операций.): </strong>
                <br/>
                <code>(+)</code> — сложение: <code>a + b</code><br/>
                <code>(-)</code> — вычитание: <code>a - b</code><br/>
                <code>(*)</code> — умножение: <code>a * b</code><br/>
                <code>(/)</code> — деление: <code>a / b</code><br/>
                <code>(%)</code> — остаток от деления: <code>a % b</code><br/>
                <code>(**)</code> — возведение в степень: <code>a ** b</code>
                <br/><br/>
                <strong>2. Операторы сравнения (Используются для сравнения двух значений.):</strong>
                <br/>
                <code>(==)</code> — нестрогое равенство<br/>
                <code>(!=)</code> — нестрогое неравенство<br/>
                <code>(===)</code> — строгое равенство<br/>
                <code>(!==)</code> — строгое неравенство<br/>
                <code>(&gt;)</code> — больше<br/>
                <code>(&lt;)</code> — меньше<br/>
                <code>(&gt;=)</code> — больше или равно<br/>
                <code>(&lt;=)</code> — меньше или равно
                <br/><br/>
                <strong>3. Логические (Используются для выполнения логических операций.):</strong>
                <br/>
                <code>(&&)</code> — логическое И<br/>
                <code>(||)</code> — логическое ИЛИ
            </>
    },
    {
        title: "6. Отличие null и undefined?",
        description:
            <>
                null явно указывает на отсутствие значения или пустое состояние. Это как бы “нуль” для объектов.
                <br/>
                null обычно используется для обозначения пустой или несуществующей ссылки на объект.
                <br/>
                undefined означает, что переменная была объявлена, но ей еще не присвоено значение.
                Это значение по умолчанию для необъявленных или неинициализированных переменных.
                <br/>
                Undefined не равен ничему кроме себя, но null == undefined;
                <br/>
                <br/>
                typeof null === “object” а typeof undefined === ‘undefined’
            </>,
    },
    {
        title: "7. Отличия межу arrow function (Стрелочные функции)  function declaration  function expression?",
        description:
            <>
                <u><strong>Function Declaration</strong></u> создается до выполнения кода, так что ее можно вызвать до
                того, как она была написана. this зависит от контекста, в котором функция вызвана.
                <br/>
                <u><strong>Function Expression</strong></u> - Функции, присвоенные переменной, как правило, не имеют
                имени и их нельзя вызвать до того, как они были определены.
                <br/>
                Declaration – function sum(a,b){};
                <br/>
                Expression – const sum = function (a,b){}
                <br/>

                <u><strong> Arrow Functions (Стрелочные функции)</strong></u>
                <br/>
                • У стрелочных функций нет собственного контекста this. Они берут его из окружающего контекста, в
                котором были созданы.
                <br/>
                • Стрелочные функции не могут быть конструкторами (т.е. их нельзя использовать с new).
                <br/>
                • У стрелочных функций нет массива arguments. Вместо этого можно использовать rest-параметры.
                <br/>
                • this в стрелочных функциях определяется в момент их создания, а не в момент вызова. То есть стрелочные
                функции всегда используют this того места, где они были написаны.
                <br/>

            </>
    },
    {
        title: "8. Разница между === и ==?",
        description:
            <>
                🔸 == (нестрогое равенство)
                <br/>
                Сравнивает значения, но может автоматически менять типы.
                <br/>
                <br/>
                "5" == 5 // true — строка превращается в число
                <br/>
                true == 1 // true — true превращается в 1
                <br/>
                <br/>
                <br/>
                🔸 === (строгое равенство)
                <br/>
                Сравнивает и значения, и типы данных.
                <br/>
                Если типы разные — результат сразу false.
                <br/>
                <br/>
                "5" === 5 // false — строка и число не равны
                <br/>
                true === 1 // false — булевый тип и число разные
                <br/>
                5 === 5 // true — и тип, и значение совпадают
            </>
    },
    {
        title: "9. This в strict и в обычном режиме?",
        description:
            <>
                <p><strong>this</strong> — это ключевое слово в JavaScript, которое указывает на объект, в контексте
                    которого выполняется код.</p>
                <br/>
                <p>🌍 <strong>В глобальной области (вне функций)</strong></p>

                <p>🔹 <strong>Обычный режим (без use strict)</strong></p>
                <pre><code>
console.log(this); // window (в браузере)
    </code></pre>
                <p>👉 this указывает на глобальный объект — в браузере это <code>window</code>.</p>
                <br/>
                <p>🔸 <strong>Strict mode ('use strict')</strong></p>
                <pre><code>
'use strict';
console.log(this); // undefined
    </code></pre>
                <p>👉 this становится <code>undefined</code>, потому что в строгом режиме JavaScript запрещает
                    автоматически привязывать глобальный объект.</p>
                <br/>
                <p>✅ <strong>В методах объекта (всегда одинаково)</strong></p>
                <pre><code>
{`const user = {
  name: 'Anna',
  showName() {
    console.log(this.name);
  }
};`}
                    user.showName(); // Anna
    </code></pre>
                <p>👉 Здесь this всегда указывает на объект <code>user</code>, вне зависимости от режима (strict или
                    нет).</p>
            </>
    },
    {
        title: "10. Что такое мемоизация и кеширование?",
        description:
            <>
                <p>🧠 Что такое Мемоизация (Memoization)</p>

                <p>Мемоизация — это частный случай кеширования, когда ты сохраняешь результат функции, чтобы не
                    пересчитывать его при тех же входных данных.</p>

                <p> 📌 Используется в основном для оптимизации производительности функций.</p>
                <br/>
                <p>📌 Что такое Кеширование (Caching)</p>
                <p> Кеширование — это сохранение данных (или результатов операций) в быстром доступе, чтобы при
                    повторном обращении не нужно было получать или вычислять их заново.</p>

                <p>🔧 Примеры:</p>
                <p> • Браузер сохраняет изображения и стили сайта (кеширует), чтобы не загружать их повторно при
                    следующем визите.</p>
                <p>• Сайт сохраняет ответ от сервера в памяти, чтобы не делать повторный запрос, если данные уже
                    есть.</p>
                <p> • React Query кеширует запросы к серверу, чтобы быстрее показывать данные.</p>

            </>
    },
    {
        title: "11. Откуда у примитивов методы, автобоксинг?",
        description:
            <>
                <p>Каждый примитив имеет собственный объект-обёртку, которые называются: String, Number, Boolean, Symbol
                    и BigInt.</p>
                <p>А прототипы этих обьектов уже имеют разный набор методов. </p>
                <p>И вот когда происходит обращение к какому-то методу у примитива, он автоматически оборачивается в
                    обьект-обертку, этот механизм называется Autoboxing</p>
                <br/>
                <p>Когда ты обращаешься к методу примитива, JavaScript на время делает такую “магическую” штуку:</p>
                <p>"hello".toUpperCase()</p>
                <p>Вот что реально происходит внутри:</p>
                <p>new String("hello").toUpperCase()</p>
                <p>То есть:</p>
                <p> 1. JavaScript берёт "hello" и оборачивает его во временный объект String.</p>
                <p> 2. У объекта String есть метод toUpperCase().</p>
                <p> 3. Выполняется метод.</p>
                <p> 4. Потом объект удаляется, и ты получаешь результат.</p>


            </>
    },
    {
        title: "12. Почему typeof массива === object?",
        description:
            <>
                <p> • Массив создаётся с помощью конструктора new Array().</p>
                <p> • Он наследует все свойства и методы от Array.prototype.</p>
                <p> • А Array.prototype, в свою очередь, наследует от Object.prototype.</p>
                <p>То есть массив — это обычный объект, просто у него есть дополнительные “фишки” для работы с
                    элементами по индексам: push, pop, length и т.д.</p>
                <p>✅ Потому что массив — это объект с номерами вместо ключей:</p>
                <pre>
<code>{`{
  0: 1,
  1: 2,
  2: 3,
  length: 3
}`}</code>
</pre>
                <p>Массивы в JavaScript — это объекты, просто они умеют работать с числами как с индексами и имеют
                    методы для удобной работы с элементами.</p>

            </>
    },
    {
        title: "13 Что такое Set??",
        description:
            <>
                <p>Set — это специальный тип коллекции в JavaScript, в котором не может быть одинаковых значений.</p>
                <p>💡 Представь:</p>
                <p>Это как коробка, куда ты кладёшь вещи. Но если ты попробуешь положить одинаковую вещь второй раз —
                    коробка её просто не примет.</p>
                <br/>
                <p>🔹 Основные особенности:</p>
                <p> ✅1. Только уникальные значения</p>
                <pre>
                    <code>
                        {
                            `
const set = new Set();
set.add(1);
set.add(1); // не добавится снова
set.add(2);
console.log(set); // Set { 1, 2 }
                            `
                        }
                    </code>
                </pre>
                <p> ✅2 Любой тип данных</p>
                <p> Ты можешь хранить и числа, и строки, и объекты:</p>
                <pre>
                    <code>
                        {
                            `set.add('hello');
set.add({name: 'John'});`
                        }
                    </code>
                </pre>
                <br/>
                <p> ✅3.Без индексов</p>
                <p>У Set нет индексов, как в массиве. Нельзя обратиться к элементу по номеру.</p>
                <p>add(value) - Добавляет значение в коллекцию</p>
                <p>delete(value) - Удаляет значение</p>
                <p>has(value) - Проверяет есть ли значение</p>
                <p>clear() - Очищает весь Set</p>
                <p>size - Показывает сколько значений в Set</p>
                <p>forEach() - Позволяет пройтись по значениям</p>
                <p>values() - Возвращает обьект итератор значений</p>
            </>
    },
    {
        title: "14 Что такое Map?",
        description:
            <>
                <p>Map — это специальная коллекция в JavaScript, которая хранит пары ключ → значение.</p>
                <p>🤔 Чем отличается от обычного объекта?</p>
                <u><strong>Map:</strong></u>
                <p>✅ Ключом может быть что угодно - строка, обьект, массив, функция и т.д.</p>
                <p>✅Содержит только то, что ты сам добавил</p>
                <p>✅ Можно легко перебирать(map.entries().map.keys(),map.values())</p>
                <u><strong>Object:</strong></u>
                <p>✅ Ключ - только строка или символ</p>
                <p>✅ Наследует свойства от прототипа (например, toString</p>
                <p>✅Нужно использовать for...in, Object.keys() и т.д</p>
                <br/>
                <u><strong>🔧 Полезные методы Map:</strong></u>
                <p>set(key, value) - добавляет значение по ключу</p>
                <p>get(key) - получает значение по ключу</p>
                <p>has(key) - проверяет, есть ли ключ</p>
                <p>delete(key) - удаляет запись по ключу</p>
                <p>clear() - очищает весь Map</p>
                <p>keys() - возвращает все ключи</p>
                <p>values() - возвращает все значения</p>
                <p>entries() - возвращает массив [ключ, значение]</p>
            </>
    },
    {
        title: "15. Что такое WeakMap отличия от Map?",
        description:
            <>
                <p>В отличии от Map в WeakMap:</p>
                <p>✅ ключи должны быть ссылочного типа (обьект, массив), а не примитивные значениями</p>
                <p>✅ если мы используем обьект в качестве ключа и на этот обьект нет ссылок, то он будет удален из
                    памяти сборщиком мусора.</p>
                <p>✅ WeakMap не поддерживает перебор и методы keys(), values(), entries(), так что нет способа взять все
                    ключи или значения из нее.</p>
            </>
    },
    {
        title: "16. Что такое WeakSet?",
        description:
            <>
                <p>WeakSet — это специальная коллекция, которая хранит только объекты (не строки, не числа).</p>
                <br/>
                <p> 1. ✅ Можно добавлять только объекты:</p>
                <pre>
<code>{`
    const ws = new WeakSet();
    ws.add({name: "Alex"}); // ок
    ws.add(123); // ❌ ошибка — нельзя добавлять числа
`}
</code>
</pre>
                <br/>
                <p> 2. ♻️ Если на объект больше нет ссылок, он автоматически удаляется из памяти:</p>
                <p> • Это помогает экономить память.</p>
                <br/>
                <p> 3. ❌ Нельзя перебрать WeakSet:</p>
                <p>• Нельзя использовать for...of, size, keys(), values(), entries() — всё это не работает.</p>
                <p>📌 Зачем нужен?</p>
                <p>WeakSet полезен, когда тебе нужно просто отмечать объекты, без перебора, и не хранить их вечно, если
                    они больше не нужны.</p>

            </>
    },
    {
        title: "17. Типы данных в JS?",
        description:
            <>
                <p>В JavaScript есть 8 основных (примитивных и не только) типов данных:</p>
                <p> 👉 1. Number – числа (Примеры: 5, 3.14, -10)</p>
                <p> 👉 2. String – строки (Примеры: "Привет", 'Мир', `Шаблонная строка`)</p>
                <p> 👉 3. Boolean – логический тип Значения: true или false ({`Пример:  5 > 3`} // true)</p>
                <p> 👉 4. Null – “пусто”, “ничего” (Пример: let a = null);</p>
                <p> 👉 5. Undefined – значение не присвоено (Пример: {`
                let x;
                console.log(x); // undefined`})</p>
                <p> 👉 6. Symbol – уникальный идентификатор (редко используется)
                    <br/>
                    (Пример: let id = Symbol("id");)</p>
                <p> 👉 7. BigInt – большие числа (больше, чем Number.MAX_SAFE_INTEGER)
                    <br/>
                    ( Пример: const big = 123456789012345678901234567890n)</p>
                <p>🧱 Сложный тип:</p>
                <p> 👉 8. Object – объекты, массивы, функции и т.д.</p>

            </>
    },

    {
        title: "18. Зачем нужен Метод PreventDefault?",
        description:
            <>
                <p>🚦 Что такое preventDefault()</p>
                <p>Когда в браузере происходит какое-то событие (например, нажатие кнопки, отправка формы, клик по
                    ссылке), у этого события есть действие по умолчанию.</p>
                <p>Примеры действий по умолчанию:</p>
                <p> • При отправке формы (submit) — страница перезагружается.</p>
                <p> • При клике на ссылку ({`<a href="..."`}) — браузер переходит на другой сайт.</p>
                <p> • При перетаскивании файла — браузер пытается открыть файл.</p>
                <br/>
                <p>Иногда мы не хотим, чтобы происходило это стандартное поведение.</p>
                <p>🎯 Для чего нужен preventDefault()</p>
                <p>Метод preventDefault() отменяет стандартное действие браузера.</p>
                <p>То есть:
                    Событие произойдёт, но браузер не сделает то, что делает обычно.</p>
                <br/>
                <pre>
                    <code>
                     {
                         `function handleSubmit(event) {
event.preventDefault(); // ⛔ Останавливаем стандартное поведение (перезагрузку страницы)
 console.log('Форма отправлена, но страница не перезагрузилась!');
               }`}
                    </code>
                </pre>
                <br/>
                <p>Без preventDefault():</p>
                <p> • Нажимаешь кнопку формы → Страница перезагружается → Все данные в форме теряются.</p>
                <p>С preventDefault():</p>
                <p> • Нажимаешь кнопку → Нет перезагрузки → Мы сами решаем, что делать дальше (например, сохранить
                    данные).
                </p>
                <p>🧠 И ещё важно:</p>
                <p> • preventDefault() останавливает только стандартное поведение.</p>
                <p> • Само событие (например, клик) продолжает происходить и может передаваться дальше.</p>

            </>
    },
    {
        title: "19. Метод stopImmediatePropagation?",
        description:
            <>
                <p>✅ stopPropagation() —
                    когда ты вызываешь его в обработчике события,
                    событие больше не поднимается к родителям,
                    но другие обработчики на этом же элементе всё ещё работают.</p>
                <p>✅ stopImmediatePropagation() —
                    останавливает вообще всё:
                    и подъём к родителям, и другие обработчики на этом элементе тоже НЕ сработают.</p>
                <br/>
                <p> 👉 тоже самое другими словами:</p>
                <p>🧠 Метод stopImmediatePropagation — не только предотвращает всплытие событий, но и предотвращает вызов
                    обработчиков события, которые были установлены на этом же элементе.</p>
                <p>🧠 Другими словами stopPropagation отключает только родительские обработчики события, а метод
                    stopImmediatePropagation - все обработчики, кроме текущего.</p>

            </>
    },
    {
        title: "20. Зачем нужен Метод stopPropagation?",
        description:
            <>
                <p>Метод stopPropagation() используется в JavaScript, чтобы остановить “всплытие события” вверх по
                    DOM-дереву.</p>
                <p>📌 Что такое всплытие события?</p>
                <p>Когда происходит событие (например, клик по кнопке), оно сначала обрабатывается на самом элементе, а
                    потом поднимается вверх по иерархии HTML — к родителям, дедушкам и так далее. Это называется
                    всплытие события (event bubbling).
                </p>
                <p>🧠 Когда это нужно?</p>
                <p> • Чтобы избежать дублирующих действий на родителях.</p>
                <p> • При модальных окнах — например, клик внутри окна не должен закрывать его, а клик вне — должен.</p>
                <p> • В сложных интерфейсах, где контролируется поведение вложенных элементов.</p>
            </>
    },
    {
        title: "21. Отличие Event.target от event.currentTarget?",
        description:
            <>
                <p>✅ event.target — это элемент, в котором происходит событие, или элемент, вызвавший событие. Это тот
                    элемент, по которому фактически кликнули.</p>
                <p>✅ event.currentTarget — это тот элемент, на котором висит обработчик события.</p>


            </>
    },
    {
        title: "22. Что такое распространение события?",
        description:
            <>
                <p>Когда ты кликаешь, например, по кнопке, событие “click” сначала идёт от самого верха документа
                    (window) до этой кнопки, а потом поднимается обратно наверх. Это и есть распространение события —
                    движение по дереву DOM.</p>
                <p>🌀 Три фазы события:</p>
                <p>1. Фаза захвата (Capturing phase)</p>
                <p> • Событие идёт сверху вниз по DOM-дереву: от window → document → html → body → и так далее до самого
                    вложенного элемента.</p>
                <p> • На этой фазе можно “поймать” событие, если явно задать {`capture: true`}.</p>
                <p>2. Фаза цели (Target phase)</p>
                <p> • Событие достигло конечного элемента, на который кликнули (event.target).</p>
                <p> • Здесь срабатывают обработчики именно этого элемента.</p>
                <p>3. Фаза всплытия (Bubbling phase)</p>
                <p> • Событие идёт обратно вверх: от event.target к родителям — div, body, html и т.д.</p>
                <p> • Это самая часто используемая фаза.</p>

            </>
    },
    {
        title: "23. Стадия погружения события, как включить?",
        description:
            <>
                <p>🔄 Что такое стадия погружения (capturing phase)?</p>
                <p>Когда происходит событие (например, клик), браузер проходит три стадии:</p>
                <p> 1. Capturing phase (Погружение) — событие идёт сверху вниз: от document к самому вложенному
                    элементу.</p>
                <p> 2. Target phase (Цель) — событие доходит до самого элемента, на котором произошло событие.</p>
                <p> 3. Bubbling phase (Всплытие) — событие поднимается обратно вверх по дереву DOM: от вложенного
                    элемента к document.</p>
                <br/>
                <p>
                    Стадия погружения по умолчанию не используется и чтобы ее включить нужно в addEventlistener передать
                    3 аргумент {`{capture: true}`}</p>

                <pre>
                    <code>
                     {`document.getElementById('inner').addEventListener('click',
  () => console.log('Inner BUTTON'),
  { capture: false } // можно не указывать — по умолчанию false
);`
                     }
                    </code>
                </pre>
            </>
    },
    {
        title: "24.  Всплытие события?",
        description:
            <>
                <p>Когда на элементе происходит событие, обработчик сначала срабатывает на нём, потом всплывает по
                    цепочке предков. Всплытие позволяет делегировать события, повесив обработчик события на родительский
                    элемент, мы можем обрабатывать клики по дочерним элементам.</p>
            </>
    },
    {
        title: "25. Как работает Event-loop, микротаски  макротаски, порядок выполнения кода, callstack и callback queue?",
        description:
            <>
                <p>🧠 Что такое Event Loop?</p>
                <p>Event Loop — это механизм в JavaScript, который следит, в каком порядке должен выполняться код:
                    синхронный, асинхронный, таймеры, события и т.д.
                </p>
                <br/>
                <p>🔄 Как работает Event Loop шаг за шагом:</p>
                <p> 1. Сначала выполняется весь синхронный код (то, что идёт по порядку, без задержек и ожиданий).</p>
                <p> 2. Когда всё синхронное выполнено, JavaScript:</p>
                <p> • Забирает все микротаски (например, - Promise.then ,MutationObserver ,queueMicrotask)</p>
                <p> • Выполняет все микротаски до конца</p>
                <p> 3. Потом берёт одну макротаску (например, setTimeout, setInterval, события DOM, евенты, таймеры,
                    fetch;).</p>
                <p> 4. После этого может произойти перерисовка страницы (если нужно).</p>
                <p> 5. И снова всё по кругу: стек, микротаски, макротаска, рендер…</p>
                <br/>
                <p>📦 Call Stack — стек вызовов</p>
                <p> • Это “стопка”, где хранятся все вызванные функции.</p>
                <p> • Когда функция вызывается — она кладётся сверху.</p>
                <p> • Когда завершается — убирается.</p>
                <p> • Работает по принципу последний пришёл — первый ушёл (LIFO).</p>
                <br/>
                <p>Асинхронные операции (setTimeout, fetch, события и т.д.) обрабатываются браузером (Web API). После
                    этого колбэки попадают в очередь (callback queue или task queue).
                </p>
                <p>🎯 Web API и Очередь (Callback Queue)</p>
                <p> • Если ты вызываешь setTimeout, fetch, или addEventListener, код идёт в Web API (в браузере).</p>
                <p> • Когда задача завершена — она попадает в очередь, ожидая, пока стек будет пуст.</p>
                <p> • Из очереди она попадает в стек и выполняется.</p>
            </>
    },
    {
        title: "26. Что такое DOM дерево?",
        description:
            <>
                <p>DOM — это структура (дерево объектов), которую браузер создаёт на основе HTML-кода.</p>
                <p>Каждый HTML-элемент (например, {`<div>, <p>, <ul>, <li>`}, и т.д.) превращается в объект, и все они
                    связаны как родители и дети.</p>
                <p>💡 Зачем нужен DOM?</p>
                <p>С помощью JavaScript ты можешь:</p>
                <p> • 📌 Найти элемент (document.querySelector('p'))</p>
                <p> • ✏️ Изменить его (element.textContent = "Новый текст")</p>
                <p> • ➕ Добавить или удалить элементы</p>
                <p> • 🎨 Изменить стили (element.style.color = "red")</p>
                <p>DOM — это мост между HTML и JavaScript. Он позволяет изменять страницу на лету, реагировать на
                    действия пользователя (клики, ввод) и делать сайт интерактивным.</p>

            </>
    },
    {
        title: "27  Отличия var let и const?",
        description:
            <>
                <p> ✅В отличие от var, область видимости let и const не функцональная, а блочная. Можно получить доступ
                    к переменным, объявленным с помощью var, до их объявления, то есть они всплывают и инициализируются
                    значением undefined при создании.</p>
                <p> ✅Основное отличие let от const заключаются в том, что переменным, объявленных с помощью ключевого
                    слова let, можно переприсвоить новое значение, а const нет. Но если const является обьектом или
                    массивом, то можно изменять внутренние поля</p>
                <p> ✅️Переменные, определенные с помощью let и const, также всплывают, но в отличие от var, не
                    инициализируются. Мы не можем к ним обращаться, пока не выполнится строка с их определением, будет
                    ReferenceError. Это называется "мертвая зона" (temporary dead zone). Когда мы пытаемся обратиться к
                    переменным до того момента как они определены.</p>
                <p> ✅️C let каждому повторению цикла соответствует независимая переменная. При использовании в цикле var
                    – одна на все итерации и видна даже после цикла (и блоков {}, кроме функций) т.к глобальная. При
                    использовании setTimeout() в цикле, console.log будет выполняться только после завершения всех
                    операций в стеке, а значит после того, как все итерации цикла буду выполнены и значение переменной i
                    достигнет цифры 5. Переменная i объявлена с помощью var. А это означает, что она является глобальной
                    и промежуточные значения такой переменной не будут сохраняться внутри стрелочной
                    функции {` () => console.log(i)`}. Таким образом, на экран 5 раз будет выведено значение 5</p>

                <br/>
                <pre>
                    <code>
                     {`for(var i = 0;i < 5; i++){
    setTimeout(function(){
        console.log('count ', i);
    }, 3000);
`}
                    </code>
                </pre>
            </>
    },

    {
        title: "28. Поднятие или же hoisting переменных?",
        description:
            <>
                <p>📌 Что такое hoisting?</p>
                <p>Поднятие или hoisting - это процесс, при котором JavaScript автоматически перемещает объявления
                    переменных и функций вверх своей области видимости ещё до выполнения кода. То есть интерпретатор
                    сначала “запоминает”, что у тебя есть какие-то переменные и функции, и только потом начинает
                    выполнять код построчно. </p>
                <p>🧠 Как это работает с функциями</p>
                <p>Если ты пишешь обычную функцию с ключевым словом function, то JavaScript “поднимает” всю эту функцию
                    вверх. Это значит, что ты можешь вызывать такую функцию даже до её определения в коде, и всё будет
                    работать.</p>
                <br/>
                <pre>
                    <code>
                     {`sayHi();

function sayHi() {
  console.log("Привет!");
}
`}
                    </code>
                </pre>
                <p>🔍 Как это работает с переменными через var</p>
                <p>Когда ты используешь var, только объявление переменной поднимается, но не её значение. То есть
                    переменная уже существует, но пока имеет значение undefined.</p>
                <br/>
                <pre>
                    <code>
                        {`console.log(a); // undefined
var a = 10;`}
                    </code>
                </pre>
                <p>⚠️ А как с let и const?</p>
                <p>С let и const всё строже. Эти переменные тоже “поднимаются”, но ты не можешь использовать их до
                    строки, где они были объявлены. Если попытаешься — получишь ошибку.</p>
                <p>Это поведение называется “временная мёртвая зона” — переменная уже есть “в памяти”, но доступ к ней
                    невозможен до инициализации.</p>
                <br/>
                <pre>
                    <code>
                        {`console.log(b); // Ошибка!
let b = 5;`}
                    </code>
                </pre>
                <p>🚫 А как насчёт стрелочных функций?</p>
                <p>Если ты пишешь стрелочную функцию и сохраняешь её в переменную (const, let или var), то это работает
                    как с обычными переменными: объявление не поднимается полностью, и ты не можешь использовать функцию
                    до того, как она объявлена.</p>
                <br/>
                <pre>
                    <code>
                        {`sayHi(); // Ошибка!

const sayHi = () => {
  console.log("Привет!");
}`}
                    </code>
                </pre>
                <br/>
                <p>💬 Итог</p>
                <p> • JavaScript сначала “просматривает” твой код и поднимает объявления функций и переменных.</p>
                <p> • Функции (function) поднимаются полностью и работают в любом месте кода.</p>
                <p> • Переменные с var поднимаются, но сначала имеют значение undefined.</p>
                <p> • Переменные с let и const тоже поднимаются, но их нельзя использовать до инициализации — это
                    вызовет ошибку.</p>
                <p> • Стрелочные функции нельзя вызывать до их определения.</p>
            </>
    },
    {
        title: "29. Область видимости, scope, виды и как работает?",
        description:
            <>
                <p>✅ Область видимости scope, это место откуда мы имеем доступ к переменным, функциям и другим данным, и можем к ним обратиться.</p>
                <p>🧠Глобальная – переменные доступны из любого места в кода. 	Переменные объявлены вне функций и блоков (if, for и т.д.).</p>
                <p>🧠Блочная – когда переменные доступны только, например в блоке if. Создаётся внутри блоков {}, таких как if, for, while. Работает только с let и const. var — игнорирует блок. </p>
                <p>🧠Функциональная— это область видимости в пределах тела функции.</p>
                <p> При создании локальной области видимости она сохраняет ссылку на внешнюю область видимости, таким образом получаются цепочки областей видимости и мы можем в 1 ОВ обращаться к переменным из 2 ОВ.</p>
                <p>ОВ создается каждый раз при вызове функции.</p>
                <p>🔁 Когда создаются области видимости?</p>
                <p>	•	При загрузке скрипта создаётся глобальная.</p>
                <p>	•	При вызове функции создаётся функциональная.</p>
                <p>	•	При входе в блок (if, for, {}) создаётся блочная, если используются let или const.</p>
                <pre>
                    <code>
                        {`
let x = 1; // глобальная

function outer() {
  let y = 2; // локальная в outer

  if (true) {
    let z = 3; // блочная в if
    console.log(x, y, z); // ✅ 1, 2, 3
  }

  // console.log(z); // ❌ ошибка, z не видно
}
outer();
                        `}
                    </code>
                </pre>
                <p>🧠 Итого:</p>
                <p> •	Глобальная область — доступна везде.</p>
                <p>  •	Функциональная область — внутри функции, создаётся при вызове.</p>
                <p>   •	Блочная область — внутри {} с let/const, ограничена блоком.</p>
                <p>•	Переменные ищутся снизу вверх по цепочке областей видимости.</p>

            </>
    },
    {
        title: "30.  Ключевое слово this, как работает и вычисляется?",
        description:
            <>
                <p>🧠this это ключевое слово в JS которое указывает на контекст исполняемого кода. То есть это ссылка на объект, который «владеет» текущим исполняемым кодом или функцией. Когда функция вызывается как метод объекта, this принимает значение объекта, по отношению к которому вызван метод, те значение обьекта перед точкой.</p>
<p>Но в стрелочных методах this относится к вышестоящему контексту т.к они не привязаны к собственным сущностям и не имеют своего this. В стрелочных функциях this определяется в момент создания, а в обычных this вычисляется в момент вызова и равен объекту перед точкой. Если такого объекта нет — тогда this будет указывать на глобальный контекст (window)</p>
         <br/>
                <p>
                    🧠 Контекст выполнения — специальная внутренняя структура данных, которая содержит информацию о вызове функции и включает в себя:</p>
                <p>- конкретное место в коде, на котором находится интерпретатор;</p>
                <p>- локальные переменные функции;</p>
                <p>- значение this;</p>
                <p>В случае с обычным объектом, если метод объекта определен как стрелочная функция, то контекст вызова (значение `this`) не будет связан с объектом, а будет наследоваться из внешнего контекста вызова.</p>
                <pre>
                    <code>
                        {
                            `        
const obj = {
  name: "hello",
  getName: () => {
    console.log(this.name);
  }
}; 
obj.getName(); // выведет undefined`
                        }
                    </code>
                </pre>
                <br/>
                <p>🧠НО В КЛАССЕ ВЫВЕДЕТ КОРРЕКТНОЕ ЗНАЧЕНИЕ name</p>
                <p>🧠В классе `Example` метод `getName` определен как стрелочная функция, которая автоматически связывает контекст вызова (значение `this`) с экземпляром класса и значение `this` внутри метода ссылается на экземпляр класса</p>
              <br/>
                <pre>
                    <code>
{
    `class Example {
name: "hello";
getName = () => {
console.log(this.name);};
}

new Example().getName()   // выведет hello`}
                    </code>
                </pre>
            </>
    },
    {
        title: "?",
        description:
            <>

            </>
    },
];

function App() {
    const [activeHtmlIndex, setActiveHtmlIndex] = useState({})
    const [activeCssIndex, setActiveCssIndex] = useState({})
    const [activeJsIndex, setActiveJsIndex] = useState({})
    const [search, setSearch] = useState('')

    const filterHtmlQuestions = search
        ? questionHtml.filter(q => q.title.toLowerCase().includes(search.toLowerCase()))
        : questionHtml

    const filterCssQuestions = search
        ? questionCss.filter(q => q.title.toLowerCase().includes(search.toLowerCase()))
        : questionCss

    const filterJsQuestion = search
        ? questionJs.filter(q => q.title.toLowerCase().includes(search.toLowerCase()))
        : questionJs


    function toggleArrowHtml(item) {
        setActiveHtmlIndex((prev) => ({
            ...prev,
            [item]: !prev[item]
        }))
    }

    function toggleArrowCss(item) {
        setActiveCssIndex((prev) => ({
            ...prev,
            [item]: !prev[item]
        }))
    }


    function toggleArrowJs(item) {
        setActiveJsIndex((prev) => ({
            ...prev,
            [item]: !prev[item]
        }))
    }

    return (
        <>
            <form action="">
                <input type="search"
                       placeholder='Поиск по названию вопроса'
                       value={search}
                       onChange={(e) => setSearch(e.target.value)}
                />
                <button type="submit" className='button-form'>🔍</button>
            </form>
            <QuestionsSection title={'HTML'} question={filterHtmlQuestions} toggleArrow={toggleArrowHtml}
                              activeIndex={activeHtmlIndex}/>
            <QuestionsSection title={'CSS'} question={filterCssQuestions} toggleArrow={toggleArrowCss}
                              activeIndex={activeCssIndex}/>
            <QuestionsSection title={'JS'} question={filterJsQuestion} toggleArrow={toggleArrowJs}
                              activeIndex={activeJsIndex}/>
        </>
    )
}


export default App



